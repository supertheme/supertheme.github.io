{"meta":{"title":"supertheme","subtitle":null,"description":null,"author":"supertheme","url":"https://supertheme.github.io","root":"/"},"pages":[{"title":"about","date":"2020-02-14T15:14:30.000Z","updated":"2020-02-14T15:14:30.657Z","comments":true,"path":"about/index.html","permalink":"https://supertheme.github.io/about/index.html","excerpt":"","text":""},{"title":"books","date":"2020-02-14T15:14:03.000Z","updated":"2020-07-14T12:08:06.519Z","comments":true,"path":"books/index.html","permalink":"https://supertheme.github.io/books/index.html","excerpt":"","text":"正在读的书: 我这一辈子(老舍) 2020.2.14 JavaScript高级程序设计 2020.3.20 一看就停不下来的中国史 2020.3.20 计划读的书: 已经读完的书: Spring Cloud微服务与Docker实战(周立) 2020.2.1~2020.3.21 Java多线程编程实战指南(黄文海) 2020.3.23~2020.3.28 大型网站技术架构核心原理与案例分析 2020.7.5~2020.7.7"},{"title":"categories","date":"2020-02-14T15:04:59.000Z","updated":"2020-02-14T15:10:32.394Z","comments":true,"path":"categories/index.html","permalink":"https://supertheme.github.io/categories/index.html","excerpt":"","text":""},{"title":"links","date":"2020-02-14T15:14:20.000Z","updated":"2020-02-14T15:14:20.261Z","comments":true,"path":"links/index.html","permalink":"https://supertheme.github.io/links/index.html","excerpt":"","text":""},{"title":"repository","date":"2020-02-14T15:12:19.000Z","updated":"2020-02-14T15:12:19.031Z","comments":true,"path":"repository/index.html","permalink":"https://supertheme.github.io/repository/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-02-14T15:05:32.000Z","updated":"2020-02-14T15:10:07.573Z","comments":true,"path":"tags/index.html","permalink":"https://supertheme.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"greenCode","slug":"greenCode","date":"2020-08-22T05:23:56.000Z","updated":"2020-08-22T05:29:19.382Z","comments":true,"path":"greenCode/","link":"","permalink":"https://supertheme.github.io/greenCode/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Java基础—String","slug":"Java基础—String","date":"2020-07-14T13:05:37.000Z","updated":"2020-07-15T02:48:00.834Z","comments":true,"path":"Java基础—String/","link":"","permalink":"https://supertheme.github.io/Java基础—String/","excerpt":"","text":"String简介​ String类位于java.lang包下，该类表示字符串，是java中比较核心的基础类之一，提供了对于字符串的拼接，截取，反转等操作。其底层使用的是一个char[]数组用来存储字符串的值。 常用方法 concat contains startsWith/endsWith substring split replace indexOf intern 需要特别注意的是，因为String是不可变的，所以上述的方法中例如concat()，substring()等方法均会返回一个new String()的实例。大多数不可变类都使用了这种模式。它被称为是函数式的做法。因为这些方法返回了一个函数的结果，而且对于原本的操作数并不进行修改。与之对应的还有 过程式的做法，通过这种方式则会对操作数的状态进行改变。 不可变性​ 在Effective Java中的第15条使可变性最小化原则中，其为我们阐述了一个类要成为不可变需要遵循的5条规则： 不要提供任何会修改对象状态的方法 保证类不会被扩展 使所有的域都是final的 使所有的域都是私有的 确保对于任何可变组件的互斥访问 上面已经提到String类本身是使用final关键字修饰的，而且其底层存储char[]也是使用final关键字修饰的，在设计和实现时，string已经严格遵循不可变的原则，那么，不可变性的优点和缺点是什么呢？在effectice java一书中也有具体的解释。 优点: 不可变对象本质上是线程安全的，他们不要求同步。 不可变对象可以自由的被共享，不需要进行保护性拷贝。 缺点： 对于每个不同的值都需要维护一个单独的对象。 equals和hashcode​ String类重写了Object的equals和hashcode方法，其中equals判断不仅比较了引用地址，而且也比较了值，而hashcode的计算如下: 123&lt;pre&gt;s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]&lt;/pre&gt; ​ 在jdk中对于string的hashcode算法如上述公式，至于为什么选择31，个人觉得首先31是个质数，使用质数算出来的hashcode碰撞概率要小，其次31与2^5靠近，底层计算应该会更加便捷。 常见面试题 ​ Q：String为什么是不可变的？ ​ A： ​ Q：创建多少个对象问题？ ​ A： ​","categories":[{"name":"java","slug":"java","permalink":"https://supertheme.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://supertheme.github.io/tags/java基础/"}]},{"title":"读书思维导图——大型网站技术架构","slug":"读书思维导图——大型网站技术架构","date":"2020-07-14T12:15:51.000Z","updated":"2020-07-14T12:18:44.095Z","comments":true,"path":"读书思维导图——大型网站技术架构/","link":"","permalink":"https://supertheme.github.io/读书思维导图——大型网站技术架构/","excerpt":"","text":"","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://supertheme.github.io/tags/读书笔记/"}]},{"title":"mysql索引","slug":"mysql索引","date":"2020-04-18T09:37:58.000Z","updated":"2020-04-18T09:37:58.904Z","comments":true,"path":"mysql索引/","link":"","permalink":"https://supertheme.github.io/mysql索引/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"mysql锁","slug":"mysql锁","date":"2020-04-17T14:13:06.000Z","updated":"2020-04-18T07:52:06.722Z","comments":true,"path":"mysql锁/","link":"","permalink":"https://supertheme.github.io/mysql锁/","excerpt":"","text":"InnoDB 共享锁 排他锁 MyISAM 共享锁 独占锁","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://supertheme.github.io/tags/mysql/"}]},{"title":"mysql事务","slug":"mysql事务","date":"2020-04-17T14:12:23.000Z","updated":"2020-04-18T09:28:52.025Z","comments":true,"path":"mysql事务/","link":"","permalink":"https://supertheme.github.io/mysql事务/","excerpt":"","text":"客户端 服务端 2.1 连接器 2.2 分析器 2.3 优化器 2.4 执行器 存储引擎 3.1 InnoDB （支持事务） 聚簇引擎（数据文件和索引文件在一起） 3.2 MyISAM （不支持事务） 非聚簇引擎 （数据文件和索引文件不在一起） 事务的特点1. 原子性（底层实现：Undo log） 2. 一致性 3. 隔离性（底层实现：锁） 4. 持久性（底层实现：Redo log） 原子性实现原理 Undo logUndo Log是为了实现事务的原子性，在MySQL数据库InnoDB存储引擎中，还用Undo log来实现多版本并发控制（简称 MVCC） 在操作任何数据之前，首先将数据备份至一个地方（这个存储数据备份的地方被称为Undo log）,然后进行数据的修改，如果出现了错误或者用户执行了Rollback，系统可以利用Undo log中的备份将数据恢复到事务开始之前的状态。 简而言之，Undo log是逻辑日志(优先在内存中记录，当内存中不够时才会在磁盘中记录)，可以理解为： 当delete一条记录，undo log会记录一条对应的Insert记录 当insert一条记录，undo log会记录一条对应的delete记录 当update一条记录，undo log会记录一条对应的相反update记录 持久性实现原理 Redo log和Undo log相反，Redo log记录的是新数据的备份。在事务提交前，只要将Redo log持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是Redo log已经持久化。系统可以根据Redo log的内容，将所有数据恢复至最新的状态。 隔离性实现原理 锁基于锁的并发控制流程 可能出现的问题：死锁 除了锁可以实现并发控制之外，还有的策略包含： 1 基于时间戳 2 基于快照隔离 3 基于有效性检查 ###MySQL的隔离级别### 事务具有隔离性，理论上事务之间的执行不会产生相互影响 然而完全的隔离性会导致系统并发性能很低，降低对资源的利用率，因此实际上对隔离性的要求会有所放宽，这也会一定程度造成对数据库一致性的要求降低 读未提交 read uncommited 脏读 不可重复读 幻读 读已提交 read commited （oracle默认隔离级别） 不可重复读 幻读 可重复读 repeatable read （Mysql默认隔离级别） 幻读 串行化 serializable 脏读 两个事务，事务1更改数据但未提交，事务2读取到了该部分数据。即事务2读取到了事务1未提交的数据，此为脏读。 不可重复读 两个事务，事务2先进行了一次读，然后事务1进行了更新操作且提交了事务，此时事物2再进行一次读，会发现两次读的结果是不一致的，此为不可重复读。 幻读 两个事务，事务1进行了Insert或者delete操作，然后提交了，事务2在查询时是查不到事务1里修改的数据的，此为幻读一致性的实现原理 原子性+隔离性+一致性","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://supertheme.github.io/tags/mysql/"}]},{"title":"redis","slug":"redis","date":"2020-04-14T13:27:44.000Z","updated":"2020-04-14T13:27:44.636Z","comments":true,"path":"redis/","link":"","permalink":"https://supertheme.github.io/redis/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"RPC","slug":"RPC","date":"2020-04-11T14:40:33.000Z","updated":"2020-04-11T14:40:33.660Z","comments":true,"path":"RPC/","link":"","permalink":"https://supertheme.github.io/RPC/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"JVM","slug":"JVM","date":"2020-04-11T04:02:24.000Z","updated":"2020-04-11T04:02:24.977Z","comments":true,"path":"JVM/","link":"","permalink":"https://supertheme.github.io/JVM/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"多线程之ThreadPool","slug":"多线程之ThreadPool","date":"2020-04-04T02:11:37.000Z","updated":"2020-04-04T02:11:37.096Z","comments":true,"path":"多线程之ThreadPool/","link":"","permalink":"https://supertheme.github.io/多线程之ThreadPool/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"多线程之同步容器","slug":"多线程之同步容器","date":"2020-04-04T02:11:16.000Z","updated":"2020-04-04T02:11:16.068Z","comments":true,"path":"多线程之同步容器/","link":"","permalink":"https://supertheme.github.io/多线程之同步容器/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"多线程之同步","slug":"多线程之同步","date":"2020-04-04T02:10:52.000Z","updated":"2020-04-12T08:11:27.334Z","comments":true,"path":"多线程之同步/","link":"","permalink":"https://supertheme.github.io/多线程之同步/","excerpt":"","text":"#线程# ##线程的生命周期状态## ##创建线程的方法## 继承Thread类并重写run方法 实现Runnable接口 实现Callable接口(带返回值的线程)##线程常用方法## run start join yield sleep stop（Deprecated） suspend（Deprecated） resume（Deprecated）##多线程的优势和风险##优势 提高系统吞吐率 提高响应性 充分利用多核 风险 线程安全 上下文切换 可靠性 ##线程安全问题## 原子性 解决方案： 1 锁 （synchronized lock） 2 CAS 可见性 解决方案： Volitile 有序性 解决方案： Volitile(禁止指令重排) #线程同步# Java中的锁可分为两类:一类是内部锁，由Java提供的关键字synchronized实现，另一类是JUC包中的Lock接口，可提供各种灵活的锁操作。Java中的锁都是互斥的。 Synchronized 在早期的Java对于Synchronized的实现中，需要涉及到用户态到内核态的切换，因此该锁又被称为重量级锁，随着JDK的不断优化，synchronized也不断升级。一般来说，锁的升级过程可大致如下: 作为锁的句柄变量通常使用private final关键词修饰，因为synchronized上锁的本质上是在对象(堆内存)上锁，所以如果修改了句柄指向的对象，那么实际上是两把锁，所以一般用private final关键词修饰。锁信息维护在对象的markword上 使用Synchronized可以同步方法，也可以同步代码块，两者锁住的都是当前对象，一般来说，推荐使用锁住同步代码块的方式，因为锁住的部分代码越少，整体的运行效率就会更高。除此之外，Synchronized也可以锁住Class对象，那么上锁的将不是实例对象，而是class对象。 synchronized本身是可重入的锁。如何理解这句话呢？因为synchronized的实现是在上锁对象头的markword上维护锁信息，每上锁一次，锁信息的计数器就加一，已经获得锁的线程无需等待，即可重新获取已经持有的锁。 Q1：线程T1正在执行同步方法，其他线程能执行非同步方法吗？ Answer: 可以，非同步方法不依赖锁信息 Q2：线程T1正在执行同步方法m1，那么其能够在m1里面调用执行该对象的其他同步方法m2吗？ Answer: 可以，锁是可重入的 子类的synchronized方法可以调用父类的synchronized方法 程序在执行过程中，如果出现异常，默认情况会释放锁，所以在并发处理的过程中，遇见异常要格外注意。 若出现异常不希望释放锁，请加上try catch Lock ###ReentantLock### ###ReentrantReadWriteLock### Volatile","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://supertheme.github.io/tags/java/"}]},{"title":"Java多线程协作","slug":"Java多线程协作","date":"2020-03-28T14:07:16.000Z","updated":"2020-03-28T14:07:16.767Z","comments":true,"path":"Java多线程协作/","link":"","permalink":"https://supertheme.github.io/Java多线程协作/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Java中的各种锁","slug":"Java中的各种锁","date":"2020-03-28T14:06:18.000Z","updated":"2020-03-28T14:06:18.192Z","comments":true,"path":"Java中的各种锁/","link":"","permalink":"https://supertheme.github.io/Java中的各种锁/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"JavaScript基础","slug":"JavaScript基础","date":"2020-03-21T11:30:19.000Z","updated":"2020-03-24T14:18:30.592Z","comments":true,"path":"JavaScript基础/","link":"","permalink":"https://supertheme.github.io/JavaScript基础/","excerpt":"","text":"基本概念 JavaScript 由ECMAScript 、BOM、 DOM三部分组成 由ECMAScript 数据类型有两种:基本数据类型Undefined Null Boolean String Number 以及复杂数据类型Object ECMAScript中没有函数签名概念，因此没有重载 ECMAScript中的函数参数实际上都会存放在arguments数组中变量作用域和内存 基本类型的值占有固定大小的内存，因此被保存在栈内存中。引用类型的值是对象，保存在堆内存中。 基本类型的复制实际上是将值进行了复制。而引用类型的复制实际上是对于引用(指针)进行了复制，在堆内存中的对象还是同一个。 EMACScript中的所有参数传递都是按照值传递 可使用typeof检测类型，instanceof检测实例类型 EMACScript没有块级作用域，所有作用域由上之下形成作用域链，子作用域可以访问父作用域的，反之不能。根作用域在window对象上。 JavaScript常用的垃圾回收算法有两个:标记清除和引用计数 显式的将不使用的变量置为null能帮助回收内存 避免循环引用 引用类型 大致分为Object Array Date RegExp Function Object类型的创建可以使用new Object()方式，也可以使用{}的字面量方式，访问其属性可以使用.的方式，也可以使用[]的方式 Array类型的创建可以使用new Array()的方式，也可以使用[]的字面量方式。Array的大小不是固定的，其length属性也不是只读的 Array的栈方法： push pop Array的队列方法：shift unshift Array的重排序方法：reverse sort Array的操作方法： concat slice splice Array的位置方法： indexOf lastIndexOf Array的迭代方法： every filter forEach map some Array的归并方法： reduce reduceRight Function实际上也是一个对象，对应的函数名实际上指针，所以其没有重载的概念。注意函数声明和函数表达式的不同，虽然只是相差一个()，函数内部有两个属性，arguments 和 this ECMAScript提供了3种包装类型，例如我们使用string.substring的方法，实际上是对string这一基本类型进行了包装转换。但是其包装变量只会存在代码执行的瞬间，在substring调用结束后会立即销毁。我们一般不显式的创建包装类。 包装类Boolean常用方法：valueOf 包装类Number常用方法： toString toFixed toExponential toPrecision 包装类String常用方法： charAt charCodeAt concat slice substr substring indexOf lastIndexOf trim toLowerCase toLocaleLowerCase toUpperCase toLocaleUpperCase match search replace split localeCompare fromCharCode ECMAScript还内置了两个兜底的对象，开发人员不用显式的实例化内置对象就可以使用。他们分时是 Global 和 Math Global对象有encodeURI encodeURLComponent decodeURI decodeURLComponent eval ,二者的区别在于encodeURI不会对本身属于URI的特殊字符进行编码(例如/,#,:等符号)，而encodeURLComponent会对所有传入的字符进行编码。一般来说，我们使用encodeURLComponent更多。 我们不能直接访问Global对象,但该角色在JavaScript中由window对象扮演 面向对象 创建对象的方式大致有三种：工厂模式 构造函数模式 原型模式 工厂模式创建的对象无法识别对象的类型 构造函数模式的缺点在于每个方法和属性都要在每个实例上重新创建一遍，造成很多大的内存浪费 原型模式三叉戟: 构造函数 原型对象 实例 ，构造函数的protoType指向原型，原型的constructor指向构造函数，实例的[[protoType]]（即proto）指向实例。通过引入原型对象这一概念，将构造函数与实例的关系切开，同时注意使用字面量重写原型会切断实例与原有原型的关系。 创建自定义类型的最常见方式就是组合使用构造函数模式与原型模式 ECMAScript对于继承的实现利用的是原型链的概念，即将原型也赋予一个proto属性，其指向其他原型对象，原型链的最顶端是Object的原型。 函数表达式-注意函数声明和函数表达式的区别-匿名函数与闭包的区别。闭包是指有权访问另一个函数作用域中变量的函数。创建闭包的常见方式就是在一个函数内部创建另一个函数-当函数返回了一个闭包后，这个函数的作用域将会一直在内存中存在直到闭包不存在位置-闭包的作用域链包含着它自己的作用域，包含函数的作用域以及全局作用域-(function(){})() 模范块级作用域，实际上是利用了匿名函数的作用域-过度使用闭包会造成大量的内存占用 BOM BOM的核心对象Window,其充当了Global对象的角色，setTimeOut setInterval alert comfirm prompt均是其常见方法。每个Frame拥有自己的Window对象 location对象 navigator对象 screen对象 history对象 DOM DOM由各种节点构成。 最基本的节点类型是Node,用于抽象的表示文档中一个独立的部分；所有其他类型都继承自Node Document类型表示整个文档，是一组分层节点的根节点。在JavaScript中，document对象时Document的一个实例。 Element节点表示文档中所有的HTML或XML元素，可以用来操作这些元素的内容和特性 还有一些节点类型，分别表示文本内容 注释 文档类型 CDATA区域以及文档片段 DOM操作很直观，但是在处理script和style上仍然存在复杂性 DOM操作很消耗性能，尽量减少DOM操作","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://supertheme.github.io/tags/前端/"}]},{"title":"session cookie token","slug":"session_cookie_token","date":"2020-03-07T07:55:17.000Z","updated":"2020-03-07T13:06:48.857Z","comments":true,"path":"session_cookie_token/","link":"","permalink":"https://supertheme.github.io/session_cookie_token/","excerpt":"","text":"","categories":[{"name":"java","slug":"java","permalink":"https://supertheme.github.io/categories/java/"}],"tags":[{"name":"security","slug":"security","permalink":"https://supertheme.github.io/tags/security/"}]},{"title":"从tcp到http再到https","slug":"从tcp到http再到https","date":"2020-03-07T07:53:30.000Z","updated":"2020-03-07T13:08:54.799Z","comments":true,"path":"从tcp到http再到https/","link":"","permalink":"https://supertheme.github.io/从tcp到http再到https/","excerpt":"","text":"OSI七层模型以及TCP/IP模型 TCP的三次握手和四次挥手三次握手 客户端： hi，服务端，我想跟你建立连接，你同意吗？ 服务端： 好的，客户端，我同意与你建立连接。我也想和你建立连接，你同意吗？ 客户端： 服务端，我同意与你建立连接。 在上述的第二步中 ，服务端做了两件事，第一件是回答客户端同意建立连接，第二件是发起与客户端连接的请求。在完成第二步的操作后，为什么还需要第三步客户端再向服务端发起一次确认呢？如果客户端发起的第一步请求因为网络延时能异常情况而导致其阻塞了，待客户端已经通过再次发起的请求与服务端完成通信结束后，此时阻塞的请求终于达到服务端，若没有第三步的二次确认，那么服务端就会跟这个异常的请求建立连接，且该链接实质上不会发送任何后续请求，导致占据链接资源。从上述三步的过程中，也可以简化如下： 客服端确认自己发送请求正常 服务端确认客户端发送请求正常，自己发送请求，接受请求正常 客户端确认服务端发送请求，接受请求正常 四次挥手 客户端： hi，服务端，我想要和你断开连接，可以吗？ 服务端： 好的，现在可以断开连接 服务端： 客户端，我想要和你断开连接，可以吗？ 客户端：好的，我同意 从上面的四步，我们可以发现为什么创建连接只需要三步，而断开连接却需要四步？在创建连接的时候，服务端接受客户端请求和自己发起请求是在一步操作完成的，而在断开连接的时候却是分开两步的，为什么要分开两步呢？因为当服务端收到客户端发起的断开请求后很可能不会直接关闭socket的，在此期间，服务端仍然可能向客户端发送数据，但是客户端却不能向服务端发送数据，因此，服务端会先回复一个响应，然后才能由服务端发起断开连接的请求。此外，在上述四步完成后，仍然需要等待2MSL(（注：MSL叫做最长报文段寿命，RFC建议为两分钟，也就是说，要经过四分钟才能进入到CLOSED状态），这也是在客户端发送报文可能丢失的情况下的一个容错机制。 http协议上述简单介绍了TCP/IP四层模型以及TCP协议建立连接和断开连接的过程，现在我们简单介绍下HTTP协议。从上图中我们可以知道HTTP协议是应用层的一个协议，其工作在TCP之上，是互联网应用最广泛的一种协议。全称是超文本传输协议。HTTP协议有以下几个特点： 基于请求/响应模型。请求和响应是成对出现的，先有请求后有响应 HTTP默认端口是80 无连接：每次连接只处理一个请求。服务端收到HTTP连接后，处理完响应，即断开一该HTTP连接 无状态：每次HTTP请求都是没有上下文的。即上一次HTTP请求的数据，在下一次HTTP请求中是无记忆的。 http协议 目前有版本HTTP/1.0 HTTP/1.1http协议由请求和响应两部分组成。其中http请求包含：请求行 请求头 请求体http响应包含：响应行 响应头 响应体 https协议","categories":[{"name":"网络","slug":"网络","permalink":"https://supertheme.github.io/categories/网络/"}],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"https://supertheme.github.io/tags/网络协议/"}]},{"title":"代理模式","slug":"设计模式_代理模式","date":"2020-02-13T03:09:38.000Z","updated":"2020-02-14T14:48:49.343Z","comments":true,"path":"设计模式_代理模式/","link":"","permalink":"https://supertheme.github.io/设计模式_代理模式/","excerpt":"","text":"什么是代理模式最近在学习spring cloud的一些基础，在看到Feign组件的时候对其实现产生了浓厚的兴趣，在度娘的帮助下，发现其主要使用了代理模式对RestTemplate做了封装，在此，简单回顾一下java中的代理模式。代理模式，顾名思义，就是在调用类和被调用类出现了一个代理类，生活中这种例子有很多，比如买车，买房等等，我们都不是直接去车企，开发商那直接买的，而是通过经销商呀，买房中介呀等渠道，这些角色扮演的就是代理的角色。我们通过这些代理，可以获得一些额外的服务。这就是代理的好处了。在软件中代理一般分为静态代理和动态代理，其中动态代理又有JDK自带的动态代理和cglib代理两种方式。 静态代理让我们还是用卖车的例子看看静态代理的实现过程先定义一个接口，代表着有卖车的服务1234public interface CarSale &#123; //卖车 void sell();&#125; 再来一个实现类，实际上这就是具体的车企了，毕竟只有它才有造车的能力 1234567public class CarSaleImpl implements CarSale &#123; @Override public void sell() &#123; System.out.println(\"卖出一辆车\"); &#125;&#125; 好了，接下来是具体的买车了，想像一下实际场景，我们都是在经销商或者4s店那里买车的，他们承担的就是代理的角色。代理的不单单只是做了卖车这个主要功能，关键是它还可以提供一些额外的附件服务呀，比如说4s店还可以提供配件，保修等功能，当然，也可以卖保险呀。 1234567891011121314public class Benz implements CarSale &#123; private CarSale carSaleImpl; public Benz(CarSale carSale) &#123; this.carSaleImpl = carSale; &#125; @Override public void sell() &#123; System.out.println(\"卖出一份保险\"); this.carSaleImpl.sell(); &#125;&#125; 从上述过程我们可以看到，代理的好处在于其在不修改目标类的基础之上，可以提供一些额外的附加功能，但是，静态代理的弊端也很显然易见，就是代理类需要与目标类实现相同的接口。我们这里只是介绍了 一个代理商，实际上车企品牌五花八门的，如果他们都需要一个代理商，我们总不能在代码中写很多重复的代理类吧，这时候，动态代理就出现了。 动态代理动态代理，与静态代理的最大区别就是其代理类是通过反射在程序运行时动态生成的。主要分为JDK动态代理和cglib动态代理两种实现。 JDK动态代理jdk动态代理的实现依赖于两个对象：Proxy 和 InvocationHandler其中proxy的作用就是代理了目标对象，而invocationHandler的作用是实现了目标对象，具体实现过程为：Proxy（jdk类库提供）根据目标对象的接口生成一个实现类，它就是动态代理类（该类型是 $Proxy+数字 ）。生成过程是：由于拿到了接口，便可以获知接口的所有信息（主要是方法的定义），也就能声明一个新的类型去实现该接口的所有方法，这些方法显然都是“虚”的，它调用另一个对象的方法。当然这个被调用的对象不能是目标对象，如果是目标对象，我们就没法增强了，等于饶了一圈又回来了。因此代理类不能直接包含被代理对象，而是一个InvocationHandler，该InvocationHandler包含被代理对象，并负责分发请求给被代理对象，分发前后均可以做增强。从原理可以看出，JDK动态代理是“对象”的代理。最终生成的动态类实际上是继承自Proxy且实现了目标对象接口的类。123456789101112131415161718192021public class DynamicProxy implements InvocationHandler &#123; /*被代理的目标对象*/ private Object target; public DynamicProxy(Object target) &#123; this.target = target; &#125; /*获取动态代理对象*/ public &lt;T&gt; T getProxy() &#123; return (T) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this); &#125; /*执行方法*/ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(\"卖了一份保险\"); method.invoke(target, args); return null; &#125;&#125; 测试方法：1234public static void main(String[] args) &#123; CarSale carSale = new DynamicProxy(new CarSaleImpl()).getProxy(); carSale.sell(); &#125; cglib动态代理JDK的动态代理机制只能代理实现了接口的类，而不能实现接口的类就不能实现JDK的动态代理，cglib是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理jdk创建对象的速度远大于cglib，这是由于cglib创建对象时需要操作字节码。cglib执行速度略大于jdk，所以比较适合单例模式。另外由于CGLIB的大部分类是直接对Java字节码进行操作，这样生成的类会在Java的永久堆中。如果动态代理操作过多，容易造成永久堆满，触发OutOfMemory异常。spring默认使用jdk动态代理，如果类没有接口，则使用cglib 代理的应用场景 AOP 事务","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://supertheme.github.io/categories/设计模式/"}],"tags":[{"name":"代理","slug":"代理","permalink":"https://supertheme.github.io/tags/代理/"}]},{"title":"LinkedList","slug":"Java_Collection_LinkedList","date":"2020-01-10T13:00:01.148Z","updated":"2020-02-14T14:46:19.317Z","comments":true,"path":"Java_Collection_LinkedList/","link":"","permalink":"https://supertheme.github.io/Java_Collection_LinkedList/","excerpt":"","text":"LinkedList简介 LinkedList源码分析 LinekdList常见操作总结 LinkedList简介 LinkedList作为List的一个实现，与ArrayList采用数组作为数据存储不一样的是，其采用了链表Node作为底层的数据存储 LinkedList不单单实现了List接口，而且也实现了Deque接口，所以可以把其当做一个双向队列使用 LinkedList允许存放Null值 LinkedList由于采用了链表作为数据存储,所以最显著的特性在于插入快，但查询慢，这一点恰恰与ArrayList相反 LinkedList源码分析 成员变量LinkedList内部持有Node来作为存储容器，我们可以看到Node的源码本身就是个双向链表的实现，在每个Node中，存放了当前节点的值，以及前一个节点prev以及后一个节点next在LinkedList内部的成员变量中，则只存放了first node 和 last node 构造方法LinkedList为我们提供了2种构造方法，分别是： 无参构造方法 使用特定集合的构造方法 第一种为LinkedList初始化，其中不含任何node，第二种直接使用Collection中的元素填充到LinkedList 核心方法LinkedList由于实现了Deque操作，因此其含有众多的队列操作方法，在此我们简单的看一下其add remove方法是如何实现的。add方法:remove方法:remove方法只会移除第一个相等的元素哟！ 队列操作linkedlist提供了基础的队列操作，总结如下: 总结 LinkedList的底层实现是链表 LinkedList是非线程安全的 LinkedList遵循 fail-fast 机制，在执行add remove 等结构性修改的操作时，会抛出异常，若要在遍历过程中添加或修改元素，可以使用迭代器 LinkedList实现了Deque接口，所以我们可以把其当做一个双向队列的数据接口来使用","categories":[{"name":"java","slug":"java","permalink":"https://supertheme.github.io/categories/java/"}],"tags":[{"name":"collection","slug":"collection","permalink":"https://supertheme.github.io/tags/collection/"}]},{"title":"var 的奇怪作用域","slug":"新文档","date":"2019-03-11T14:42:08.843Z","updated":"2020-02-14T14:49:29.662Z","comments":true,"path":"新文档/","link":"","permalink":"https://supertheme.github.io/新文档/","excerpt":"","text":"var 的奇怪作用域function f(shouldInitialize: boolean) {if (shouldInitialize) {var x = 10;} return x;} f(true); // returns ‘10’f(false); // returns ‘undefined’","categories":[{"name":"javascript","slug":"javascript","permalink":"https://supertheme.github.io/categories/javascript/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://supertheme.github.io/tags/前端/"}]},{"title":"Springboot","slug":"springboot","date":"2018-12-30T11:44:05.571Z","updated":"2020-02-14T14:48:01.127Z","comments":true,"path":"springboot/","link":"","permalink":"https://supertheme.github.io/springboot/","excerpt":"","text":"##springboot的目标 为所有Spring开发者提供一个更快且更广泛的入门体验 开箱即用且能快速应对需求的变化(开闭原则) 提供一系列与原先大型项目等价的基础服务(嵌入式中间件,security health check) 消除XML配置##环境搭建 Springboot 2.1.1.RELEASE JAVA 8 Spring Framework 5.1.3.RELEASE Maven 3.3+ Tomcat 9.0 tips 因为spring默认el表达式的占位符是${..}风格的，所有如果要使用Maven filtering,请使用@..@的格式，或者在maven propert中重新定义resource.delimiter Externalized Configuration 配置随机值 RandomValuePropertySource 可以使用${random.value}等表达式配置随机值 获取命令行参数值 SpringApplication将命令行参数(以–开头)转化为Property，并且可以通过Environment访问到,如果不希望Environment访问到，可以配置如下：SpringApplication.setAddCommandLineProperties(false) 配置文件 1.","categories":[{"name":"spring","slug":"spring","permalink":"https://supertheme.github.io/categories/spring/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://supertheme.github.io/tags/springboot/"}]},{"title":"ArrayList","slug":"Java_Collection_ArrayList","date":"2018-12-16T10:41:27.250Z","updated":"2020-02-14T14:45:58.591Z","comments":true,"path":"Java_Collection_ArrayList/","link":"","permalink":"https://supertheme.github.io/Java_Collection_ArrayList/","excerpt":"","text":"ArrayList简介 ArrayList源码分析 ArrayList扩容机制 ArrayList简介 ArrayList可以理解成一个”动态数组”，由于Java中数组都是固定大小的，但ArrayList是一个可以动态的添加和删除元素的List,其底层仍然是由数组实现的。ArrayList继承自AbstractList，并且实现了List,RandomAccess,Cloneable,Serializable这四个接口。 ArrayList与Vector有很大的相似性，最大的区别在于ArrayList是线程不安全的，而Vector是线程安全的，若要使用线程安全的，请使用List list = Collections.synchronizedList(new ArrayList(...)); ArrayList与LinkedList同样也有很大的相似性，二者作为List的主要两个实现类，主要区别在于ArrayList的add/remove操作慢，而get操作快，而LinkedList则恰好相反，究其原因还是在于底层实现一个是数组，一个是链表ArrayList源码分析 成员变量ArrayList内部持有Object[]来作为存储容器，其默认的CAPACITY大小为10，最大的容量为Integer.MAX_VALUE 构造方法ArrayList为我们提供了3种构造方法，分别是： 指定初始容量的构造方法 无参构造方法 使用特定集合的构造方法 第一种为elementData初始化成对应的指定容量大小，第二种直接构造一个空的elementData，第三种则是通过Arrays.copyof来初始话elementData并赋值 核心方法由于ArrayList本身的底层实现是数组，所以对于其操作的add remove get set 等方法全部都是基于数据元素的操作，从源码截取了几个方法，本身逻辑均不复杂 remove方法: 内部类ArrayList还内置了三个内部类来帮助我们完成一些其他的操作，其中包含实现了Iterator接口的Itr，实现了ListIterator接口的ListItr，还有一个SubList Iterator由于Itr和ListItr只是实现的接口略有差异，在此截取了Itr执行remove的代码片段，我们可以看到，在Itr内部中含有一个新的expectedModCount变量，其初始值为modCount，在执行remove操作的时候，会先进行判断expectedModCount与modCount是否相等，若相等，则执行remove操作，若不相等，则会抛出ConcurrentModificationException异常，相信小伙伴们对这个异常并不陌生，平时在代码中对List写foreach循环的时候，若执行了remove操作，则就会遇见该异常了，而如果使用Iterator去执行remove操作，就可以正常删除了。原因就在于此哈。 SubListArrayList提供了SubList的内部类，其主要作用是提供对于List子集合的一个视图，我们需要注意的是，这仅仅是一个视图（与数据库里的概念类似）,任何对原List的操作均会体现在SubList上，而任何在SubList上的操作也会同样的反应到List上，因为其本质上都是对同一个elementData做操作，因此，我们在进行add、remove等structurally modified的操作时，一定要特别注意subList也会进行相应的变化 ArrayList扩容机制 为了充分的利用内存空间，代码规范也会让我们在初始化ArrayList就为其指定capacity，因此，我们有必要也了解一下ArrayList中的扩容机制，在执行add，addAll等操作时，会进行capacity的check，与当前elementData的size进行对比，若需要扩容，则会newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)，新容量将会是旧容量的1.5倍 总结 ArrayList的底层实现是数组 ArrayList是非线程安全的 ArrayList最好在初始化时就为其指定容量大小，每次在做add操作时，会触发容量检查，若当前数组小于元素个数时，会新申请1.5倍的数组空间，将原有数组复制 ArrayList遵循 fail-fast 机制，在执行add remove 等结构性修改的操作时，会抛出异常，若要在遍历过程中添加或修改元素，可以使用迭代器 ArrayList提供的subList方法实际上是返回的是其一个内部类，底层仍然指向同一片数组空间，只是作为视图使用，无论对List本身操作或者对SubList操作，二者相互之间均彼此影响","categories":[{"name":"java","slug":"java","permalink":"https://supertheme.github.io/categories/java/"}],"tags":[{"name":"collection","slug":"collection","permalink":"https://supertheme.github.io/tags/collection/"}]},{"title":"ThreadLocal","slug":"Java_ThreadLocal","date":"2018-12-01T13:01:18.695Z","updated":"2020-02-14T14:47:33.286Z","comments":true,"path":"Java_ThreadLocal/","link":"","permalink":"https://supertheme.github.io/Java_ThreadLocal/","excerpt":"","text":"ThreadLocal ThreadLocal的初步认识 深入源码解析ThreadLocal ThreadLocal的具体使用场景 总结 ThreadLocal,顾名思义是线程本地变量，刚开始使用时总会不理解这个local的含义所在，所以我们先看一个例子，在没有使用ThreadLocal的时候是怎样的。","categories":[{"name":"java","slug":"java","permalink":"https://supertheme.github.io/categories/java/"}],"tags":[{"name":"thread","slug":"thread","permalink":"https://supertheme.github.io/tags/thread/"}]}]}