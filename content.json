{"meta":{"title":"supertheme","subtitle":null,"description":null,"author":"supertheme","url":"https://supertheme.github.io","root":"/"},"pages":[],"posts":[{"title":"代理模式","slug":"设计模式_代理模式","date":"2020-02-13T03:09:38.000Z","updated":"2020-02-13T03:11:36.905Z","comments":true,"path":"设计模式_代理模式/","link":"","permalink":"https://supertheme.github.io/设计模式_代理模式/","excerpt":"","text":"什么是代理模式最近在学习spring cloud的一些基础，在看到Feign组件的时候对其实现产生了浓厚的兴趣，在度娘的帮助下，发现其主要使用了代理模式对RestTemplate做了封装，在此，简单回顾一下java中的代理模式。代理模式，顾名思义，就是在调用类和被调用类出现了一个代理类，生活中这种例子有很多，比如买车，买房等等，我们都不是直接去车企，开发商那直接买的，而是通过经销商呀，买房中介呀等渠道，这些角色扮演的就是代理的角色。我们通过这些代理，可以获得一些额外的服务。这就是代理的好处了。在软件中代理一般分为静态代理和动态代理，其中动态代理又有JDK自带的动态代理和cglib代理两种方式。 静态代理让我们还是用卖车的例子看看静态代理的实现过程先定义一个接口，代表着有卖车的服务1234public interface CarSale &#123; //卖车 void sell();&#125; 再来一个实现类，实际上这就是具体的车企了，毕竟只有它才有造车的能力 1234567public class CarSaleImpl implements CarSale &#123; @Override public void sell() &#123; System.out.println(\"卖出一辆车\"); &#125;&#125; 好了，接下来是具体的买车了，想像一下实际场景，我们都是在经销商或者4s店那里买车的，他们承担的就是代理的角色。代理的不单单只是做了卖车这个主要功能，关键是它还可以提供一些额外的附件服务呀，比如说4s店还可以提供配件，保修等功能，当然，也可以卖保险呀。 1234567891011121314public class Benz implements CarSale &#123; private CarSale carSaleImpl; public Benz(CarSale carSale) &#123; this.carSaleImpl = carSale; &#125; @Override public void sell() &#123; System.out.println(\"卖出一份保险\"); this.carSaleImpl.sell(); &#125;&#125; 从上述过程我们可以看到，代理的好处在于其在不修改目标类的基础之上，可以提供一些额外的附加功能，但是，静态代理的弊端也很显然易见，就是代理类需要与目标类实现相同的接口。我们这里只是介绍了 一个代理商，实际上车企品牌五花八门的，如果他们都需要一个代理商，我们总不能在代码中写很多重复的代理类吧，这时候，动态代理就出现了。 动态代理动态代理，与静态代理的最大区别就是其代理类是通过反射在程序运行时动态生成的。主要分为JDK动态代理和cglib动态代理两种实现。 JDK动态代理jdk动态代理的实现依赖于两个对象：Proxy 和 InvocationHandler其中proxy的作用就是代理了目标对象，而invocationHandler的作用是实现了目标对象，具体实现过程为：Proxy（jdk类库提供）根据目标对象的接口生成一个实现类，它就是动态代理类（该类型是 $Proxy+数字 ）。生成过程是：由于拿到了接口，便可以获知接口的所有信息（主要是方法的定义），也就能声明一个新的类型去实现该接口的所有方法，这些方法显然都是“虚”的，它调用另一个对象的方法。当然这个被调用的对象不能是目标对象，如果是目标对象，我们就没法增强了，等于饶了一圈又回来了。因此代理类不能直接包含被代理对象，而是一个InvocationHandler，该InvocationHandler包含被代理对象，并负责分发请求给被代理对象，分发前后均可以做增强。从原理可以看出，JDK动态代理是“对象”的代理。最终生成的动态类实际上是继承自Proxy且实现了目标对象接口的类。123456789101112131415161718192021public class DynamicProxy implements InvocationHandler &#123; /*被代理的目标对象*/ private Object target; public DynamicProxy(Object target) &#123; this.target = target; &#125; /*获取动态代理对象*/ public &lt;T&gt; T getProxy() &#123; return (T) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this); &#125; /*执行方法*/ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(\"卖了一份保险\"); method.invoke(target, args); return null; &#125;&#125; 测试方法：1234public static void main(String[] args) &#123; CarSale carSale = new DynamicProxy(new CarSaleImpl()).getProxy(); carSale.sell(); &#125; cglib动态代理JDK的动态代理机制只能代理实现了接口的类，而不能实现接口的类就不能实现JDK的动态代理，cglib是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理jdk创建对象的速度远大于cglib，这是由于cglib创建对象时需要操作字节码。cglib执行速度略大于jdk，所以比较适合单例模式。另外由于CGLIB的大部分类是直接对Java字节码进行操作，这样生成的类会在Java的永久堆中。如果动态代理操作过多，容易造成永久堆满，触发OutOfMemory异常。spring默认使用jdk动态代理，如果类没有接口，则使用cglib 代理的应用场景 AOP 事务","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://supertheme.github.io/tags/设计模式/"}]},{"title":"LinkedList","slug":"Java_Collection_LinkedList","date":"2020-01-10T13:00:01.148Z","updated":"2020-01-11T15:45:31.660Z","comments":true,"path":"Java_Collection_LinkedList/","link":"","permalink":"https://supertheme.github.io/Java_Collection_LinkedList/","excerpt":"","text":"LinkedList简介 LinkedList源码分析 LinekdList常见操作总结 LinkedList简介 LinkedList作为List的一个实现，与ArrayList采用数组作为数据存储不一样的是，其采用了链表Node作为底层的数据存储 LinkedList不单单实现了List接口，而且也实现了Deque接口，所以可以把其当做一个双向队列使用 LinkedList允许存放Null值 LinkedList由于采用了链表作为数据存储,所以最显著的特性在于插入快，但查询慢，这一点恰恰与ArrayList相反 LinkedList源码分析 成员变量LinkedList内部持有Node来作为存储容器，我们可以看到Node的源码本身就是个双向链表的实现，在每个Node中，存放了当前节点的值，以及前一个节点prev以及后一个节点next在LinkedList内部的成员变量中，则只存放了first node 和 last node 构造方法LinkedList为我们提供了2种构造方法，分别是： 无参构造方法 使用特定集合的构造方法 第一种为LinkedList初始化，其中不含任何node，第二种直接使用Collection中的元素填充到LinkedList 核心方法LinkedList由于实现了Deque操作，因此其含有众多的队列操作方法，在此我们简单的看一下其add remove方法是如何实现的。add方法:remove方法:remove方法只会移除第一个相等的元素哟！ 队列操作linkedlist提供了基础的队列操作，总结如下: 总结 LinkedList的底层实现是链表 LinkedList是非线程安全的 LinkedList遵循 fail-fast 机制，在执行add remove 等结构性修改的操作时，会抛出异常，若要在遍历过程中添加或修改元素，可以使用迭代器 LinkedList实现了Deque接口，所以我们可以把其当做一个双向队列的数据接口来使用","categories":[],"tags":[{"name":"collection","slug":"collection","permalink":"https://supertheme.github.io/tags/collection/"}]},{"title":"","slug":"新文档","date":"2019-03-11T14:42:08.843Z","updated":"2019-03-11T14:43:10.623Z","comments":true,"path":"新文档/","link":"","permalink":"https://supertheme.github.io/新文档/","excerpt":"","text":"var 的奇怪作用域function f(shouldInitialize: boolean) {if (shouldInitialize) {var x = 10;} return x;} f(true); // returns ‘10’f(false); // returns ‘undefined’","categories":[],"tags":[]},{"title":"","slug":"springboot","date":"2018-12-30T11:44:05.571Z","updated":"2019-01-07T13:45:32.006Z","comments":true,"path":"springboot/","link":"","permalink":"https://supertheme.github.io/springboot/","excerpt":"","text":"##springboot的目标 为所有Spring开发者提供一个更快且更广泛的入门体验 开箱即用且能快速应对需求的变化(开闭原则) 提供一系列与原先大型项目等价的基础服务(嵌入式中间件,security health check) 消除XML配置##环境搭建 Springboot 2.1.1.RELEASE JAVA 8 Spring Framework 5.1.3.RELEASE Maven 3.3+ Tomcat 9.0 tips 因为spring默认el表达式的占位符是${..}风格的，所有如果要使用Maven filtering,请使用@..@的格式，或者在maven propert中重新定义resource.delimiter Externalized Configuration 配置随机值 RandomValuePropertySource 可以使用${random.value}等表达式配置随机值 获取命令行参数值 SpringApplication将命令行参数(以–开头)转化为Property，并且可以通过Environment访问到,如果不希望Environment访问到，可以配置如下：SpringApplication.setAddCommandLineProperties(false) 配置文件 1.","categories":[],"tags":[]},{"title":"ArrayList","slug":"Java_Collection_ArrayList","date":"2018-12-16T10:41:27.250Z","updated":"2020-01-11T15:25:47.276Z","comments":true,"path":"Java_Collection_ArrayList/","link":"","permalink":"https://supertheme.github.io/Java_Collection_ArrayList/","excerpt":"","text":"ArrayList简介 ArrayList源码分析 ArrayList扩容机制 ArrayList简介 ArrayList可以理解成一个”动态数组”，由于Java中数组都是固定大小的，但ArrayList是一个可以动态的添加和删除元素的List,其底层仍然是由数组实现的。ArrayList继承自AbstractList，并且实现了List,RandomAccess,Cloneable,Serializable这四个接口。 ArrayList与Vector有很大的相似性，最大的区别在于ArrayList是线程不安全的，而Vector是线程安全的，若要使用线程安全的，请使用List list = Collections.synchronizedList(new ArrayList(...)); ArrayList与LinkedList同样也有很大的相似性，二者作为List的主要两个实现类，主要区别在于ArrayList的add/remove操作慢，而get操作快，而LinkedList则恰好相反，究其原因还是在于底层实现一个是数组，一个是链表ArrayList源码分析 成员变量ArrayList内部持有Object[]来作为存储容器，其默认的CAPACITY大小为10，最大的容量为Integer.MAX_VALUE 构造方法ArrayList为我们提供了3种构造方法，分别是： 指定初始容量的构造方法 无参构造方法 使用特定集合的构造方法 第一种为elementData初始化成对应的指定容量大小，第二种直接构造一个空的elementData，第三种则是通过Arrays.copyof来初始话elementData并赋值 核心方法由于ArrayList本身的底层实现是数组，所以对于其操作的add remove get set 等方法全部都是基于数据元素的操作，从源码截取了几个方法，本身逻辑均不复杂 remove方法: 内部类ArrayList还内置了三个内部类来帮助我们完成一些其他的操作，其中包含实现了Iterator接口的Itr，实现了ListIterator接口的ListItr，还有一个SubList Iterator由于Itr和ListItr只是实现的接口略有差异，在此截取了Itr执行remove的代码片段，我们可以看到，在Itr内部中含有一个新的expectedModCount变量，其初始值为modCount，在执行remove操作的时候，会先进行判断expectedModCount与modCount是否相等，若相等，则执行remove操作，若不相等，则会抛出ConcurrentModificationException异常，相信小伙伴们对这个异常并不陌生，平时在代码中对List写foreach循环的时候，若执行了remove操作，则就会遇见该异常了，而如果使用Iterator去执行remove操作，就可以正常删除了。原因就在于此哈。 SubListArrayList提供了SubList的内部类，其主要作用是提供对于List子集合的一个视图，我们需要注意的是，这仅仅是一个视图（与数据库里的概念类似）,任何对原List的操作均会体现在SubList上，而任何在SubList上的操作也会同样的反应到List上，因为其本质上都是对同一个elementData做操作，因此，我们在进行add、remove等structurally modified的操作时，一定要特别注意subList也会进行相应的变化 ArrayList扩容机制 为了充分的利用内存空间，代码规范也会让我们在初始化ArrayList就为其指定capacity，因此，我们有必要也了解一下ArrayList中的扩容机制，在执行add，addAll等操作时，会进行capacity的check，与当前elementData的size进行对比，若需要扩容，则会newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)，新容量将会是旧容量的1.5倍 总结 ArrayList的底层实现是数组 ArrayList是非线程安全的 ArrayList最好在初始化时就为其指定容量大小，每次在做add操作时，会触发容量检查，若当前数组小于元素个数时，会新申请1.5倍的数组空间，将原有数组复制 ArrayList遵循 fail-fast 机制，在执行add remove 等结构性修改的操作时，会抛出异常，若要在遍历过程中添加或修改元素，可以使用迭代器 ArrayList提供的subList方法实际上是返回的是其一个内部类，底层仍然指向同一片数组空间，只是作为视图使用，无论对List本身操作或者对SubList操作，二者相互之间均彼此影响","categories":[],"tags":[{"name":"collection","slug":"collection","permalink":"https://supertheme.github.io/tags/collection/"}]},{"title":"","slug":"Java_ThreadLocal","date":"2018-12-01T13:01:18.695Z","updated":"2018-12-01T13:39:17.855Z","comments":true,"path":"Java_ThreadLocal/","link":"","permalink":"https://supertheme.github.io/Java_ThreadLocal/","excerpt":"","text":"ThreadLocal ThreadLocal的初步认识 深入源码解析ThreadLocal ThreadLocal的具体使用场景 总结 ThreadLocal,顾名思义是线程本地变量，刚开始使用时总会不理解这个local的含义所在，所以我们先看一个例子，在没有使用ThreadLocal的时候是怎样的。","categories":[],"tags":[]}]}