{"meta":{"title":"supertheme","subtitle":null,"description":null,"author":"supertheme","url":"https://supertheme.github.io","root":"/"},"pages":[{"title":"about","date":"2020-02-14T15:14:30.000Z","updated":"2020-02-14T15:14:30.657Z","comments":true,"path":"about/index.html","permalink":"https://supertheme.github.io/about/index.html","excerpt":"","text":""},{"title":"books","date":"2020-02-14T15:14:03.000Z","updated":"2020-03-21T12:22:07.963Z","comments":true,"path":"books/index.html","permalink":"https://supertheme.github.io/books/index.html","excerpt":"","text":"正在读的书: 我这一辈子(老舍) 2020.2.14 JavaScript高级程序设计 2020.3.20 一看就停不下来的中国史 2020.3.20 计划读的书: 已经读完的书: Spring Cloud微服务与Docker实战(周立) 2020.2.1~2020.3.21"},{"title":"categories","date":"2020-02-14T15:04:59.000Z","updated":"2020-02-14T15:10:32.394Z","comments":true,"path":"categories/index.html","permalink":"https://supertheme.github.io/categories/index.html","excerpt":"","text":""},{"title":"links","date":"2020-02-14T15:14:20.000Z","updated":"2020-02-14T15:14:20.261Z","comments":true,"path":"links/index.html","permalink":"https://supertheme.github.io/links/index.html","excerpt":"","text":""},{"title":"repository","date":"2020-02-14T15:12:19.000Z","updated":"2020-02-14T15:12:19.031Z","comments":true,"path":"repository/index.html","permalink":"https://supertheme.github.io/repository/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-02-14T15:05:32.000Z","updated":"2020-02-14T15:10:07.573Z","comments":true,"path":"tags/index.html","permalink":"https://supertheme.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript基础","slug":"JavaScript基础","date":"2020-03-21T11:30:19.000Z","updated":"2020-03-22T04:57:24.736Z","comments":true,"path":"JavaScript基础/","link":"","permalink":"https://supertheme.github.io/JavaScript基础/","excerpt":"","text":"基本概念 JavaScript 由ECMAScript 、BOM、 DOM三部分组成 由ECMAScript 数据类型有两种:基本数据类型Undefined Null Boolean String Number 以及复杂数据类型Object ECMAScript中没有函数签名概念，因此没有重载 ECMAScript中的函数参数实际上都会存放在arguments数组中变量作用域和内存 基本类型的值占有固定大小的内存，因此被保存在栈内存中。引用类型的值是对象，保存在堆内存中。 基本类型的复制实际上是将值进行了复制。而引用类型的复制实际上是对于引用(指针)进行了复制，在堆内存中的对象还是同一个。 EMACScript中的所有参数传递都是按照值传递 可使用typeof检测类型，instanceof检测实例类型 EMACScript没有块级作用域，所有作用域由上之下形成作用域链，子作用域可以访问父作用域的，反之不能。根作用域在window对象上。 JavaScript常用的垃圾回收算法有两个:标记清除和引用计数 显式的将不使用的变量置为null能帮助回收内存 避免循环引用 引用类型 大致分为Object Array Date RegExp Function Object类型的创建可以使用new Object()方式，也可以使用{}的字面量方式，访问其属性可以使用.的方式，也可以使用[]的方式 Array类型的创建可以使用new Array()的方式，也可以使用[]的字面量方式。Array的大小不是固定的，其length属性也不是只读的 Array的栈方法： push pop Array的队列方法：shift unshift Array的重排序方法：reverse sort Array的操作方法： concat slice splice Array的位置方法： indexOf lastIndexOf Array的迭代方法： every filter forEach map some Array的归并方法： reduce reduceRight Function实际上也是一个对象，对应的函数名实际上指针，所以其没有重载的概念。注意函数声明和函数表达式的不同，虽然只是相差一个()，函数内部有两个属性，arguments 和 this ECMAScript提供了3种包装类型，例如我们使用string.substring的方法，实际上是对string这一基本类型进行了包装转换。但是其包装变量只会存在代码执行的瞬间，在substring调用结束后会立即销毁。我们一般不显式的创建包装类。 包装类Boolean常用方法：valueOf 包装类Number常用方法： toString toFixed toExponential toPrecision 包装类String常用方法： charAt charCodeAt concat slice substr substring indexOf lastIndexOf trim toLowerCase toLocaleLowerCase toUpperCase toLocaleUpperCase match search replace split localeCompare fromCharCode ECMAScript还内置了两个兜底的对象，开发人员不用显式的实例化内置对象就可以使用。他们分时是 Global 和 Math Global对象有encodeURI encodeURLComponent decodeURI decodeURLComponent eval ,二者的区别在于encodeURI不会对本身属于URI的特殊字符进行编码(例如/,#,:等符号)，而encodeURLComponent会对所有传入的字符进行编码。一般来说，我们使用encodeURLComponent更多。 我们不能直接访问Global对象,但该角色在JavaScript中由window对象扮演","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://supertheme.github.io/tags/前端/"}]},{"title":"session cookie token","slug":"session_cookie_token","date":"2020-03-07T07:55:17.000Z","updated":"2020-03-07T13:06:48.857Z","comments":true,"path":"session_cookie_token/","link":"","permalink":"https://supertheme.github.io/session_cookie_token/","excerpt":"","text":"","categories":[{"name":"java","slug":"java","permalink":"https://supertheme.github.io/categories/java/"}],"tags":[{"name":"security","slug":"security","permalink":"https://supertheme.github.io/tags/security/"}]},{"title":"从tcp到http再到https","slug":"从tcp到http再到https","date":"2020-03-07T07:53:30.000Z","updated":"2020-03-07T13:08:54.799Z","comments":true,"path":"从tcp到http再到https/","link":"","permalink":"https://supertheme.github.io/从tcp到http再到https/","excerpt":"","text":"OSI七层模型以及TCP/IP模型 TCP的三次握手和四次挥手三次握手 客户端： hi，服务端，我想跟你建立连接，你同意吗？ 服务端： 好的，客户端，我同意与你建立连接。我也想和你建立连接，你同意吗？ 客户端： 服务端，我同意与你建立连接。 在上述的第二步中 ，服务端做了两件事，第一件是回答客户端同意建立连接，第二件是发起与客户端连接的请求。在完成第二步的操作后，为什么还需要第三步客户端再向服务端发起一次确认呢？如果客户端发起的第一步请求因为网络延时能异常情况而导致其阻塞了，待客户端已经通过再次发起的请求与服务端完成通信结束后，此时阻塞的请求终于达到服务端，若没有第三步的二次确认，那么服务端就会跟这个异常的请求建立连接，且该链接实质上不会发送任何后续请求，导致占据链接资源。从上述三步的过程中，也可以简化如下： 客服端确认自己发送请求正常 服务端确认客户端发送请求正常，自己发送请求，接受请求正常 客户端确认服务端发送请求，接受请求正常 四次挥手 客户端： hi，服务端，我想要和你断开连接，可以吗？ 服务端： 好的，现在可以断开连接 服务端： 客户端，我想要和你断开连接，可以吗？ 客户端：好的，我同意 从上面的四步，我们可以发现为什么创建连接只需要三步，而断开连接却需要四步？在创建连接的时候，服务端接受客户端请求和自己发起请求是在一步操作完成的，而在断开连接的时候却是分开两步的，为什么要分开两步呢？因为当服务端收到客户端发起的断开请求后很可能不会直接关闭socket的，在此期间，服务端仍然可能向客户端发送数据，但是客户端却不能向服务端发送数据，因此，服务端会先回复一个响应，然后才能由服务端发起断开连接的请求。此外，在上述四步完成后，仍然需要等待2MSL(（注：MSL叫做最长报文段寿命，RFC建议为两分钟，也就是说，要经过四分钟才能进入到CLOSED状态），这也是在客户端发送报文可能丢失的情况下的一个容错机制。 http协议上述简单介绍了TCP/IP四层模型以及TCP协议建立连接和断开连接的过程，现在我们简单介绍下HTTP协议。从上图中我们可以知道HTTP协议是应用层的一个协议，其工作在TCP之上，是互联网应用最广泛的一种协议。全称是超文本传输协议。HTTP协议有以下几个特点： 基于请求/响应模型。请求和响应是成对出现的，先有请求后有响应 HTTP默认端口是80 无连接：每次连接只处理一个请求。服务端收到HTTP连接后，处理完响应，即断开一该HTTP连接 无状态：每次HTTP请求都是没有上下文的。即上一次HTTP请求的数据，在下一次HTTP请求中是无记忆的。 http协议 目前有版本HTTP/1.0 HTTP/1.1http协议由请求和响应两部分组成。其中http请求包含：请求行 请求头 请求体http响应包含：响应行 响应头 响应体 https协议","categories":[{"name":"网络","slug":"网络","permalink":"https://supertheme.github.io/categories/网络/"}],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"https://supertheme.github.io/tags/网络协议/"}]},{"title":"代理模式","slug":"设计模式_代理模式","date":"2020-02-13T03:09:38.000Z","updated":"2020-02-14T14:48:49.343Z","comments":true,"path":"设计模式_代理模式/","link":"","permalink":"https://supertheme.github.io/设计模式_代理模式/","excerpt":"","text":"什么是代理模式最近在学习spring cloud的一些基础，在看到Feign组件的时候对其实现产生了浓厚的兴趣，在度娘的帮助下，发现其主要使用了代理模式对RestTemplate做了封装，在此，简单回顾一下java中的代理模式。代理模式，顾名思义，就是在调用类和被调用类出现了一个代理类，生活中这种例子有很多，比如买车，买房等等，我们都不是直接去车企，开发商那直接买的，而是通过经销商呀，买房中介呀等渠道，这些角色扮演的就是代理的角色。我们通过这些代理，可以获得一些额外的服务。这就是代理的好处了。在软件中代理一般分为静态代理和动态代理，其中动态代理又有JDK自带的动态代理和cglib代理两种方式。 静态代理让我们还是用卖车的例子看看静态代理的实现过程先定义一个接口，代表着有卖车的服务1234public interface CarSale &#123; //卖车 void sell();&#125; 再来一个实现类，实际上这就是具体的车企了，毕竟只有它才有造车的能力 1234567public class CarSaleImpl implements CarSale &#123; @Override public void sell() &#123; System.out.println(\"卖出一辆车\"); &#125;&#125; 好了，接下来是具体的买车了，想像一下实际场景，我们都是在经销商或者4s店那里买车的，他们承担的就是代理的角色。代理的不单单只是做了卖车这个主要功能，关键是它还可以提供一些额外的附件服务呀，比如说4s店还可以提供配件，保修等功能，当然，也可以卖保险呀。 1234567891011121314public class Benz implements CarSale &#123; private CarSale carSaleImpl; public Benz(CarSale carSale) &#123; this.carSaleImpl = carSale; &#125; @Override public void sell() &#123; System.out.println(\"卖出一份保险\"); this.carSaleImpl.sell(); &#125;&#125; 从上述过程我们可以看到，代理的好处在于其在不修改目标类的基础之上，可以提供一些额外的附加功能，但是，静态代理的弊端也很显然易见，就是代理类需要与目标类实现相同的接口。我们这里只是介绍了 一个代理商，实际上车企品牌五花八门的，如果他们都需要一个代理商，我们总不能在代码中写很多重复的代理类吧，这时候，动态代理就出现了。 动态代理动态代理，与静态代理的最大区别就是其代理类是通过反射在程序运行时动态生成的。主要分为JDK动态代理和cglib动态代理两种实现。 JDK动态代理jdk动态代理的实现依赖于两个对象：Proxy 和 InvocationHandler其中proxy的作用就是代理了目标对象，而invocationHandler的作用是实现了目标对象，具体实现过程为：Proxy（jdk类库提供）根据目标对象的接口生成一个实现类，它就是动态代理类（该类型是 $Proxy+数字 ）。生成过程是：由于拿到了接口，便可以获知接口的所有信息（主要是方法的定义），也就能声明一个新的类型去实现该接口的所有方法，这些方法显然都是“虚”的，它调用另一个对象的方法。当然这个被调用的对象不能是目标对象，如果是目标对象，我们就没法增强了，等于饶了一圈又回来了。因此代理类不能直接包含被代理对象，而是一个InvocationHandler，该InvocationHandler包含被代理对象，并负责分发请求给被代理对象，分发前后均可以做增强。从原理可以看出，JDK动态代理是“对象”的代理。最终生成的动态类实际上是继承自Proxy且实现了目标对象接口的类。123456789101112131415161718192021public class DynamicProxy implements InvocationHandler &#123; /*被代理的目标对象*/ private Object target; public DynamicProxy(Object target) &#123; this.target = target; &#125; /*获取动态代理对象*/ public &lt;T&gt; T getProxy() &#123; return (T) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this); &#125; /*执行方法*/ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(\"卖了一份保险\"); method.invoke(target, args); return null; &#125;&#125; 测试方法：1234public static void main(String[] args) &#123; CarSale carSale = new DynamicProxy(new CarSaleImpl()).getProxy(); carSale.sell(); &#125; cglib动态代理JDK的动态代理机制只能代理实现了接口的类，而不能实现接口的类就不能实现JDK的动态代理，cglib是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理jdk创建对象的速度远大于cglib，这是由于cglib创建对象时需要操作字节码。cglib执行速度略大于jdk，所以比较适合单例模式。另外由于CGLIB的大部分类是直接对Java字节码进行操作，这样生成的类会在Java的永久堆中。如果动态代理操作过多，容易造成永久堆满，触发OutOfMemory异常。spring默认使用jdk动态代理，如果类没有接口，则使用cglib 代理的应用场景 AOP 事务","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://supertheme.github.io/categories/设计模式/"}],"tags":[{"name":"代理","slug":"代理","permalink":"https://supertheme.github.io/tags/代理/"}]},{"title":"LinkedList","slug":"Java_Collection_LinkedList","date":"2020-01-10T13:00:01.148Z","updated":"2020-02-14T14:46:19.317Z","comments":true,"path":"Java_Collection_LinkedList/","link":"","permalink":"https://supertheme.github.io/Java_Collection_LinkedList/","excerpt":"","text":"LinkedList简介 LinkedList源码分析 LinekdList常见操作总结 LinkedList简介 LinkedList作为List的一个实现，与ArrayList采用数组作为数据存储不一样的是，其采用了链表Node作为底层的数据存储 LinkedList不单单实现了List接口，而且也实现了Deque接口，所以可以把其当做一个双向队列使用 LinkedList允许存放Null值 LinkedList由于采用了链表作为数据存储,所以最显著的特性在于插入快，但查询慢，这一点恰恰与ArrayList相反 LinkedList源码分析 成员变量LinkedList内部持有Node来作为存储容器，我们可以看到Node的源码本身就是个双向链表的实现，在每个Node中，存放了当前节点的值，以及前一个节点prev以及后一个节点next在LinkedList内部的成员变量中，则只存放了first node 和 last node 构造方法LinkedList为我们提供了2种构造方法，分别是： 无参构造方法 使用特定集合的构造方法 第一种为LinkedList初始化，其中不含任何node，第二种直接使用Collection中的元素填充到LinkedList 核心方法LinkedList由于实现了Deque操作，因此其含有众多的队列操作方法，在此我们简单的看一下其add remove方法是如何实现的。add方法:remove方法:remove方法只会移除第一个相等的元素哟！ 队列操作linkedlist提供了基础的队列操作，总结如下: 总结 LinkedList的底层实现是链表 LinkedList是非线程安全的 LinkedList遵循 fail-fast 机制，在执行add remove 等结构性修改的操作时，会抛出异常，若要在遍历过程中添加或修改元素，可以使用迭代器 LinkedList实现了Deque接口，所以我们可以把其当做一个双向队列的数据接口来使用","categories":[{"name":"java","slug":"java","permalink":"https://supertheme.github.io/categories/java/"}],"tags":[{"name":"collection","slug":"collection","permalink":"https://supertheme.github.io/tags/collection/"}]},{"title":"var 的奇怪作用域","slug":"新文档","date":"2019-03-11T14:42:08.843Z","updated":"2020-02-14T14:49:29.662Z","comments":true,"path":"新文档/","link":"","permalink":"https://supertheme.github.io/新文档/","excerpt":"","text":"var 的奇怪作用域function f(shouldInitialize: boolean) {if (shouldInitialize) {var x = 10;} return x;} f(true); // returns ‘10’f(false); // returns ‘undefined’","categories":[{"name":"javascript","slug":"javascript","permalink":"https://supertheme.github.io/categories/javascript/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://supertheme.github.io/tags/前端/"}]},{"title":"Springboot","slug":"springboot","date":"2018-12-30T11:44:05.571Z","updated":"2020-02-14T14:48:01.127Z","comments":true,"path":"springboot/","link":"","permalink":"https://supertheme.github.io/springboot/","excerpt":"","text":"##springboot的目标 为所有Spring开发者提供一个更快且更广泛的入门体验 开箱即用且能快速应对需求的变化(开闭原则) 提供一系列与原先大型项目等价的基础服务(嵌入式中间件,security health check) 消除XML配置##环境搭建 Springboot 2.1.1.RELEASE JAVA 8 Spring Framework 5.1.3.RELEASE Maven 3.3+ Tomcat 9.0 tips 因为spring默认el表达式的占位符是${..}风格的，所有如果要使用Maven filtering,请使用@..@的格式，或者在maven propert中重新定义resource.delimiter Externalized Configuration 配置随机值 RandomValuePropertySource 可以使用${random.value}等表达式配置随机值 获取命令行参数值 SpringApplication将命令行参数(以–开头)转化为Property，并且可以通过Environment访问到,如果不希望Environment访问到，可以配置如下：SpringApplication.setAddCommandLineProperties(false) 配置文件 1.","categories":[{"name":"spring","slug":"spring","permalink":"https://supertheme.github.io/categories/spring/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://supertheme.github.io/tags/springboot/"}]},{"title":"ArrayList","slug":"Java_Collection_ArrayList","date":"2018-12-16T10:41:27.250Z","updated":"2020-02-14T14:45:58.591Z","comments":true,"path":"Java_Collection_ArrayList/","link":"","permalink":"https://supertheme.github.io/Java_Collection_ArrayList/","excerpt":"","text":"ArrayList简介 ArrayList源码分析 ArrayList扩容机制 ArrayList简介 ArrayList可以理解成一个”动态数组”，由于Java中数组都是固定大小的，但ArrayList是一个可以动态的添加和删除元素的List,其底层仍然是由数组实现的。ArrayList继承自AbstractList，并且实现了List,RandomAccess,Cloneable,Serializable这四个接口。 ArrayList与Vector有很大的相似性，最大的区别在于ArrayList是线程不安全的，而Vector是线程安全的，若要使用线程安全的，请使用List list = Collections.synchronizedList(new ArrayList(...)); ArrayList与LinkedList同样也有很大的相似性，二者作为List的主要两个实现类，主要区别在于ArrayList的add/remove操作慢，而get操作快，而LinkedList则恰好相反，究其原因还是在于底层实现一个是数组，一个是链表ArrayList源码分析 成员变量ArrayList内部持有Object[]来作为存储容器，其默认的CAPACITY大小为10，最大的容量为Integer.MAX_VALUE 构造方法ArrayList为我们提供了3种构造方法，分别是： 指定初始容量的构造方法 无参构造方法 使用特定集合的构造方法 第一种为elementData初始化成对应的指定容量大小，第二种直接构造一个空的elementData，第三种则是通过Arrays.copyof来初始话elementData并赋值 核心方法由于ArrayList本身的底层实现是数组，所以对于其操作的add remove get set 等方法全部都是基于数据元素的操作，从源码截取了几个方法，本身逻辑均不复杂 remove方法: 内部类ArrayList还内置了三个内部类来帮助我们完成一些其他的操作，其中包含实现了Iterator接口的Itr，实现了ListIterator接口的ListItr，还有一个SubList Iterator由于Itr和ListItr只是实现的接口略有差异，在此截取了Itr执行remove的代码片段，我们可以看到，在Itr内部中含有一个新的expectedModCount变量，其初始值为modCount，在执行remove操作的时候，会先进行判断expectedModCount与modCount是否相等，若相等，则执行remove操作，若不相等，则会抛出ConcurrentModificationException异常，相信小伙伴们对这个异常并不陌生，平时在代码中对List写foreach循环的时候，若执行了remove操作，则就会遇见该异常了，而如果使用Iterator去执行remove操作，就可以正常删除了。原因就在于此哈。 SubListArrayList提供了SubList的内部类，其主要作用是提供对于List子集合的一个视图，我们需要注意的是，这仅仅是一个视图（与数据库里的概念类似）,任何对原List的操作均会体现在SubList上，而任何在SubList上的操作也会同样的反应到List上，因为其本质上都是对同一个elementData做操作，因此，我们在进行add、remove等structurally modified的操作时，一定要特别注意subList也会进行相应的变化 ArrayList扩容机制 为了充分的利用内存空间，代码规范也会让我们在初始化ArrayList就为其指定capacity，因此，我们有必要也了解一下ArrayList中的扩容机制，在执行add，addAll等操作时，会进行capacity的check，与当前elementData的size进行对比，若需要扩容，则会newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)，新容量将会是旧容量的1.5倍 总结 ArrayList的底层实现是数组 ArrayList是非线程安全的 ArrayList最好在初始化时就为其指定容量大小，每次在做add操作时，会触发容量检查，若当前数组小于元素个数时，会新申请1.5倍的数组空间，将原有数组复制 ArrayList遵循 fail-fast 机制，在执行add remove 等结构性修改的操作时，会抛出异常，若要在遍历过程中添加或修改元素，可以使用迭代器 ArrayList提供的subList方法实际上是返回的是其一个内部类，底层仍然指向同一片数组空间，只是作为视图使用，无论对List本身操作或者对SubList操作，二者相互之间均彼此影响","categories":[{"name":"java","slug":"java","permalink":"https://supertheme.github.io/categories/java/"}],"tags":[{"name":"collection","slug":"collection","permalink":"https://supertheme.github.io/tags/collection/"}]},{"title":"ThreadLocal","slug":"Java_ThreadLocal","date":"2018-12-01T13:01:18.695Z","updated":"2020-02-14T14:47:33.286Z","comments":true,"path":"Java_ThreadLocal/","link":"","permalink":"https://supertheme.github.io/Java_ThreadLocal/","excerpt":"","text":"ThreadLocal ThreadLocal的初步认识 深入源码解析ThreadLocal ThreadLocal的具体使用场景 总结 ThreadLocal,顾名思义是线程本地变量，刚开始使用时总会不理解这个local的含义所在，所以我们先看一个例子，在没有使用ThreadLocal的时候是怎样的。","categories":[{"name":"java","slug":"java","permalink":"https://supertheme.github.io/categories/java/"}],"tags":[{"name":"thread","slug":"thread","permalink":"https://supertheme.github.io/tags/thread/"}]}]}